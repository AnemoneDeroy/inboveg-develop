---
title: "Tutorial on how to retrieve data from the INBOVEG database"
author: "Hans Van Calster & Els De Bie"
date: "1 maart 2019 (updated `r Sys.Date()`)"
output: html_document
---


```{r setup }



```

# Packages and connection

The following packages are needed to run this code:

* knitr
* tidyverse
* DBI
* odbc
* glue

Be sure you have reading-rights for CYDONIA
otherwise place an ICTcall (ict.helpdesk@inbo.be)


```{r setup, eval = FALSE, warning=FALSE}

library(tidyverse)
library(DBI)
library(glue)
library(knitr)
library(odbc)

opts_chunk$set(echo = TRUE)

```
-- krijg volgende error als ik bovenstaande chunk laat lopen "Error: attempt to use zero-length variable name""


The following R-code can be used to establish a connection to INBOVEG by means of a connection string:

<!--better to use a connection string than dsn. dsn requires extra steps and settings in windows odbc manager-->

```{r}
con <- dbConnect(odbc::odbc(), .connection_string = "Driver=SQL Server;Server=inbo-sql07-prd.inbo.be,1433;Database=D0010_00_Cydonia;Trusted_Connection=Yes;")
```
-- krijg volgende error als ik bovenstaande chunk laat lopen "Error: attempt to use zero-length variable name""


# Retrieving data

## *iv_Survey*:

-gives the list of all surveys in InboVeg

- define the name of the survey by Survey <- name
- or define a part of the name of the survey by contains <- part_name (dit later als eerste simpele werkt)
- or define the owner of the surveys you are looking for, by owner <- name_owner (dit later als eerste simpele werkt)

 
```{r, include = FALSE}

survey_info <- function(survey) {
  dbGetQuery(con, glue_sql(
             "SELECT
             ivS.Id
            , ivS.Name
            , ivS.Description
            , ivS.Owner
            , ivS.creator
    FROM [dbo].[ivSurvey] ivS
    WHERE ivS.Name LIKE {survey}", 
      ivS.Name = survey))
 }

```

surveyinfo <- survey_info(name of the survey)

Later verder uitbreiden zoals: 
  survey <- "name"
  --- string <- "part_name"
  --- owner <- "name_owner"
 
survey_info <- function(survey, string, owner) {
  dbGetQuery(con, glue_sql(
             "SELECT
             ivS.Id
            , ivS.Name
            , ivS.Description
            , ivS.Owner
            , ivS.creator
    FROM [dbo].[ivSurvey] ivS
    WHERE ivS.Name LIKE {survey}, 
    OR ivS.Name = filter(ivS, contains{string})
    OR ivS.owner LIKE {owner}", 
    ivS.Name = survey, 
    ivS.Name = filter(contains(string), 
    ivS.owner = owner))
 }


## *iv_headerinfo*: 

- contains metadata for a vegetation-relevé (one row per vegetation-relevé identified by 'RecordingGivid')
- specify two parameters for the function:
    - RecType = c('Classic', 'Classic-emmer', 'Classic-ketting', 'BioHab', 'ABS')
    - SurveyName = to get the list, run the code under "## iv_survey
    
    
```{r, include=FALSE}

header_info <- function(Name, RecType) {
  dbGetQuery(con,
    "SELECT 
      ivR.[RecordingGivid]
      , ivS.Name
      , ivR.UserReference
      , ivR.LocationCode
      , ivR.Latitude
      , ivR.Longitude
      , ivR.Area
      , ivR.Length
      , ivR.Width
      , ivR.SurveyId
      , coalesce(area, convert( nvarchar(20),ivR.Length * ivR.Width)) as B
      FROM [dbo].[ivRecording] ivR
      INNER JOIN [dbo].[ivSurvey] ivS on ivS.Id = ivR.SurveyId
      where ivR.NeedsWork = 0
      AND Name = Name,
      RecType = RecType
      
      ;")
}

```

Give up survey-name and Recordtype in this function

Headerinfo <- header_info(Name, RecType)

## *iv_Classification*:

- gives the bwk-code or N2000code, recorderd by the observer of the relevé
- specify the name of the survey you want to use. if none, all the classification records in inboveg will be given


 
```{r, include = FALSE}
classification_info <- function(survey) {
  dbGetQuery(con,
    "SELECT 
        ivR.RecordingGivid
      , ivS.Name as survey
      , ivRLClas.Classif
    --, ivRLClas.ClassifResource
      , ivRLRes_Class.ActionGroup
      , ivRLRes_Class.ListName
    --, ftAGL_Class.ListGIVID
    --, ftBWK.ListGIVID
      , ftBWK.Description as LocalClassification
      , ftN2k.Description  as Habitattype
      , ivRLClas.Cover
      , ftC.PctValue
    FROM ivRecording ivR
INNER JOIN ivSurvey ivS on ivS.Id = ivR.surveyId
LEFT JOIN [dbo].[ivRLClassification] ivRLClas on ivRLClas.RecordingID = ivR.Id
LEFT JOIN [dbo].[ivRLResources] ivRLRes_Class on ivRLRes_Class.ResourceGIVID = ivRLClas.ClassifResource
LEFT JOIN [syno].[Futon_dbo_ftActionGroupList] ftAGL_Class on ftAGL_Class.ActionGroup = ivRLRes_Class.ActionGroup collate Latin1_General_CI_AI
													AND ftAGL_Class.ListName = ivRLRes_Class.ListName collate Latin1_General_CI_AI
 --MAAR hoe los ik dit op als er twee type lijsten aanhangen? gevolg van vroeger opdeling in Local en AnnexI classification?
LEFT JOIN [syno].[Futon_dbo_ftBWKValues] ftBWK on ftBWK.Code = ivRLClas.Classif collate Latin1_General_CI_AI 
											AND ftBWK.ListGIVID = ftAGL_Class.ListGIVID 
LEFT JOIN [syno].[Futon_dbo_ftN2kValues] ftN2K on ftN2K.Code = ivRLClas.Classif collate Latin1_General_CI_AI 
											AND ftN2K.ListGIVID = ftAGL_Class.ListGIVID 
LEFT JOIN [dbo].[ivRLResources] ivRLR_C on ivRLR_C.ResourceGIVID = ivRLClas.CoverResource
LEFT JOIN [syno].[Futon_dbo_ftActionGroupList] ftAGL_C on ftAGL_C.ActionGroup = ivRLR_C.ActionGroup collate Latin1_General_CI_AI
												AND ftAGL_C.ListName = ivRLR_C.ListName collate Latin1_General_CI_AI
LEFT JOIN [syno].[Futon_dbo_ftCoverValues] ftC on ftC.Code = ivRLClas.Cover collate Latin1_General_CI_AI
											AND ftAGL_C.ListGIVID = ftC.ListGIVID 
WHERE ivRLClas.Classif is not NULL 
")

}

```





To close the connection:

```{r}
dbDisconnect(con)

rm(con)
```

